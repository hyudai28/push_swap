ra
ra
ra
ra
pb
ra
pb
pb
pb
ra
pa
sb
rrb
ra
pa
pa
pa
pa
ra
ra
ra
pb
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
argc = [10]
ary[0] = [5]
ary[1] = [4]
ary[2] = [6]
ary[3] = [7]
ary[4] = [1]
ary[5] = [9]
ary[6] = [2]
ary[7] = [3]
ary[8] = [0]
do over 6
________half_a_to_b________
	この関数のゴールは中央値よりも下の値をスタックAからスタックBに飛ばすことが目的です。
	以下の手順で実施されます。
	1.中央値を手に入れるget_median
	2.ここに最適化用の処理が入る可能性があります。
	3.while文で中央値よりも小さい値をBに飛ばします
		3-1.aがソート済みの場所まで確認した場合whileが終了します。
		3-2.aのインデックスがaの最後まで進んだ時whileが終了します。
	4.未実装__aのアドレスを先頭に戻します。
median_num = 4
a->head = 1, a->num = 0
a->next->fin = [0], list_index = [10], num_size = [9]
=========print start=========

[a]node[1] = [4]
[a]node[2] = [6]
[a]node[3] = [7]
[a]node[4] = [9]
[a]node[5] = [5]

=========print fin=========
=========print start=========

[b]node[1] = [0]
[b]node[2] = [3]
[b]node[3] = [2]
[b]node[4] = [1]

=========print fin=========
=====half a to b=========
b_quick_sort
__________b_quick_sort_________
	この関数のゴールはBの要素を４個以下にすることです。
	以下の手順で実施されます。
	1.while文 Bの中にあるリストが４つ以下になるまでソート
		1-1.Bの中央値を手に入れる
		1-2.中央値よりも上の値をAに戻す。
		ところでこれ関数にできそうですね
=========print start=========

[a]node[1] = [4]
[a]node[2] = [6]
[a]node[3] = [7]
[a]node[4] = [9]
[a]node[5] = [5]

=========print fin=========
=========print start=========

[b]node[1] = [0]
[b]node[2] = [3]
[b]node[3] = [2]
[b]node[4] = [1]

=========print fin=========
_____allsort_____
	この関数では残り４つ以下となったBをソートする関数です。
	以下の手順で実装されます。
	1.４つの場合は先頭をAに飛ばします。
	2.３つとなったBでソートをかけます。
	3.Aに飛ばします。
	4.１を実行した場合は戻す前にAの先頭と比較を行い
	Aの先頭の方が小さい場合は先にAの先頭をraしフラグを立てます。
=========print start=========

[a]node[1] = [4]
[a]node[2] = [6]
[a]node[3] = [7]
[a]node[4] = [9]
[a]node[5] = [5]
[a]node[6] = [0]

=========print fin=========
=========print start=========

[b]node[1] = [1]
[b]node[2] = [2]
[b]node[3] = [3]

=========print fin=========
=========print start=========

[a]node[1] = [1]
[a]node[2] = [4]
[a]node[3] = [6]
[a]node[4] = [7]
[a]node[5] = [9]
[a]node[6] = [5]
[a]node[7] = [0]

=========print fin=========
=========print start=========

[b]node[1] = [3]
[b]node[2] = [2]

=========print fin=========
________half_a_to_b________
	この関数のゴールは中央値よりも下の値をスタックAからスタックBに飛ばすことが目的です。
	以下の手順で実施されます。
	1.中央値を手に入れるget_median
	2.ここに最適化用の処理が入る可能性があります。
	3.while文で中央値よりも小さい値をBに飛ばします
		3-1.aがソート済みの場所まで確認した場合whileが終了します。
		3-2.aのインデックスがaの最後まで進んだ時whileが終了します。
	4.未実装__aのアドレスを先頭に戻します。
median_num = 4
a->head = 1, a->num = 0
a->next->fin = [1], list_index = [1], num_size = [9]
=========print start=========

[a]node[1] = [4]
[a]node[2] = [6]
[a]node[3] = [7]
[a]node[4] = [9]
[a]node[5] = [5]
[a]node[6] = [0]

=========print fin=========
=========print start=========

[b]node[1] = [1]
[b]node[2] = [3]
[b]node[3] = [2]

=========print fin=========
=====half a to b=========
b_quick_sort
__________b_quick_sort_________
	この関数のゴールはBの要素を４個以下にすることです。
	以下の手順で実施されます。
	1.while文 Bの中にあるリストが４つ以下になるまでソート
	sb
ra
pa
pa
pa
ra
ra
ra
	1-1.Bの中央値を手に入れる
		1-2.中央値よりも上の値をAに戻す。
		ところでこれ関数にできそうですね
=========print start=========

[a]node[1] = [4]
[a]node[2] = [6]
[a]node[3] = [7]
[a]node[4] = [9]
[a]node[5] = [5]
[a]node[6] = [0]

=========print fin=========
=========print start=========

[b]node[1] = [1]
[b]node[2] = [3]
[b]node[3] = [2]

=========print fin=========
_____allsort_____
	この関数では残り４つ以下となったBをソートする関数です。
	以下の手順で実装されます。
	1.４つの場合は先頭をAに飛ばします。
	2.３つとなったBでソートをかけます。
	3.Aに飛ばします。
	4.１を実行した場合は戻す前にAの先頭と比較を行い
	Aの先頭の方が小さい場合は先にAの先頭をraしフラグを立てます。
=========print start=========


=========print fin=========
=========print start=========

[b]node[1] = [2]
[b]node[2] = [1]
[b]node[3] = [4]
[b]node[4] = [6]
[b]node[5] = [7]
[b]node[6] = [9]
[b]node[7] = [5]
[b]node[8] = [0]
[b]node[9] = [3]

=========print fin=========
________half_a_to_b________
	この関数のゴールは中央値よりも下の値をスタックAからスタックBに飛ばすことが目的です。
	以下の手順で実施されます。
	1.中央値を手に入れるget_median
	2.ここに最適化用の処理が入る可能性があります。
	3.while文で中央値よりも小さい値をBに飛ばします
		3-1.aがソート済みの場所まで確認した場合whileが終了します。
		3-2.aのインデックスがaの最後まで進んだ時whileが終了します。
	4.未実装__aのアドレスを先頭に戻します。
median_num = 0
a->head = 1, a->num = 0
=========print start=========


=========print fin=========
